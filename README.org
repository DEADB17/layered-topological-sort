#+title: Layered topological sort (JavaScript)
#+date: <2020-01-26 Sun>
#+AUTHOR: DEADB17
#+EMAIL: deadb17@gmail.com
#+language: en
#+exclude_tags: noexport
#+creator: Emacs 27.0.50 (Org mode 9.3.1)

Layer-based scheduling algorithm for parallel tasks with dependencies.

Determines which tasks can be executed in parallel, by evaluating dependencies
and scheduling them to start /as soon as possible/ or /as late as possible/.

/Acknowledgement: The code is based on [[https://github.com/quipo/dependencysolver][quipo/dependencysolver]] and the
introduction is taken from its [[https://github.com/quipo/dependencysolver/blob/2b009cb4ddcc2d0c564450ff99dcdc7c8959f79d/README.md][README.md]]./

* Introduction

Given a list of entries (each task with its own dependency list), it can sort
them in layers of execution, where all task in the same layer can be executed
in parallel, and have no other dependency than the previous layer.

For instance, given the tasks ~A~, ~B~, ~C~, ~D~, where ~B~ and ~C~ depend on
~A~, and ~D~ depends on ~B~ and ~C~, this function will return three layers of
execution (as ~B~ and ~C~ can be executed in parallel after ~A~ completes):

*Dependency tree*
#+begin_example
    A
   / \
  B   C
   \ /
    D
#+end_example

*Resulting execution layers*
| Layer 1 | A    |
| Layer 2 | B, C |
| Layer 3 | D    |

** JavaScript representation
- A *Task* is represented by a string.
- An *Entry* is a two element array:
  1. A *Task*.
  2. An array of tasks representing the *Dependencies*.
- Entries are grouped into an array.
#+name: intro-example
#+begin_src js
  [
    ['A', []],
    ['B', ['A']],
    ['C', ['A']],
    ['D', ['B', 'C']],
  ]
#+end_src

Running
#+begin_src js
  asap([
    ['A', []],
    ['B', ['A']],
    ['C', ['A']],
    ['D', ['B', 'C']],
  ]);
#+end_src

#+name: run-intro-example
#+begin_src js :noweb yes :results output :exports results :wrap src js
  const entries =
  <<intro-example>>
  <<test>>
  asaplog([ [ 'A' ], [ 'B', 'C' ], [ 'D' ] ])
#+end_src

Produces an array of layers, where each layer is an array of tasks.

#+RESULTS: run-intro-example
#+begin_src js
[ [ 'A' ], [ 'B', 'C' ], [ 'D' ] ]
#+end_src

** As soon or as late as possible
Entries are scheduled to start either /as soon as possible/ (=asap=) or /as late
as possible/ (=alap=). Depending on the duration and order of tasks each can
produce a shorter schedule.

#+name: asap-alap-example
#+begin_src js
  [
    ['A', []],
    ['B', []],
    ['C', ['A']],
    ['D', ['B', 'C']],
  ]
#+end_src

#+name: run-alap-example
#+begin_src js :noweb yes :results output :exports results :wrap src js
  const entries =
  <<asap-alap-example>>
  <<test>>
  alaplog([ [ 'A' ], [ 'B', 'C' ], [ 'D' ] ]);
#+end_src

=alap= produces:

#+RESULTS: run-alap-example
#+begin_src js
[ [ 'A' ], [ 'B', 'C' ], [ 'D' ] ]
#+end_src

#+name: run-asap-example
#+begin_src js :noweb yes :results output :exports results :wrap src js
  const entries =
  <<asap-alap-example>>
  <<test>>
  asaplog([ [ 'A', 'B' ], [ 'C' ], [ 'D' ] ]);
#+end_src

=asap= produces:

#+RESULTS: run-asap-example
#+begin_src js
[ [ 'A', 'B' ], [ 'C' ], [ 'D' ] ]
#+end_src

*** =alap= is better than =asap=
alap [[./images/alap-win.svg]]

asap [[./images/asap-lose.svg]]

*** =asap= is better than =alap=
asap [[./images/asap-win.svg]]

alap [[./images/alap-lose.svg]]

* Examples
** No dependencies
#+name: no-deps
#+begin_src js
  [
    ['A', []],
    ['B', []],
    ['C', []],
    ['D', []],
  ]
#+end_src

#+name: run-no-deps
#+begin_src js :noweb yes :results output :exports results :wrap src js
  const entries =
  <<no-deps>>
  <<test>>
  asaplog([ [ 'A', 'B', 'C', 'D' ] ]);
#+end_src

Both =asap= and =alap= produce a single layer, since all tasks are independent:

#+RESULTS: run-no-deps
#+begin_src js
[ [ 'A', 'B', 'C', 'D' ] ]
#+end_src
** Interdependent
#+name: inter-dep
#+begin_src js
  [
    ['A', []],
    ['B', ['A']],
    ['C', ['B']],
    ['D', ['C']],
  ]
#+end_src

#+name: run-inter-dep
#+begin_src js :noweb yes :results output :exports results :wrap src js
  const entries =
  <<inter-dep>>
  <<test>>
  asaplog([ [ 'A' ], [ 'B' ], [ 'C' ], [ 'D' ] ]);
#+end_src

Both =asap= and =alap= produce one layer per task since they are interdependent
and can't run in parallel:

#+RESULTS: run-inter-dep
#+begin_src js
[ [ 'A' ], [ 'B' ], [ 'C' ], [ 'D' ] ]
#+end_src
** Circular dependencies
#+name: circular
#+begin_src js
  [
    ['A', ['B']],
    ['B', ['A']],
  ]
#+end_src

#+name: run-circular
#+begin_src js :noweb yes :results output :exports results :wrap src js
  const entries =
  <<circular>>
  <<test>>
  asaplog([]);
#+end_src

Circular dependencies produce no results:

#+RESULTS: run-circular
#+begin_src js
[]
#+end_src

** Complex
#+name: complex
#+begin_src js
  [
    ['A', []],
    ['B', ['A']],
    ['C', ['A', 'D']],
    ['D', ['E', 'B']],
    ['E', []],
    ['F', ['A', 'D', 'G']],
    ['G', ['H', 'I', 'J']],
    ['H', ['K']],
    ['I', ['K']],
    ['J', ['K']],
    ['K', []],
  ]
#+end_src

=asap= produces:

#+name: run-complex-asap
#+begin_src js :noweb yes :results output :exports results :wrap src js
    const entries =
    <<complex>>
    <<test>>
    asaplog([
      [ 'A', 'E', 'K' ],
      [ 'B', 'H', 'I', 'J' ],
      [ 'D', 'G' ],
      [ 'C', 'F' ]
    ]);
#+end_src

#+RESULTS: run-complex-asap
#+begin_src js
[
  [ 'A', 'E', 'K' ],
  [ 'B', 'H', 'I', 'J' ],
  [ 'D', 'G' ],
  [ 'C', 'F' ]
]
#+end_src

while =alap= produces:

#+name: run-complex-alap
#+begin_src js :noweb yes :results output :exports results :wrap src js
    const entries =
    <<complex>>
    <<test>>
    alaplog([
      [ 'A', 'K' ],
      [ 'B', 'E', 'H', 'I', 'J' ],
      [ 'D', 'G' ],
      [ 'C', 'F' ]
    ]);
#+end_src

#+RESULTS: run-complex-alap
#+begin_src js
[
  [ 'A', 'K' ],
  [ 'B', 'E', 'H', 'I', 'J' ],
  [ 'D', 'G' ],
  [ 'C', 'F' ]
]
#+end_src

* JavaScript Implementation
** Types
#+name: types
#+begin_src js
  /**
   ,* @typedef {string} Task
   ,* @typedef {Task[]} Deps
   ,* @typedef {[Task, Deps]} Entry
   ,* @typedef {Entry[]} Entries
   ,* @typedef {Array<Array<Task>>} Layers
   ,* @typedef {{[task: string]: {[task: string]: boolean}}} Dependencies
   ,*/
#+end_src

** ALAP
#+name: alap
#+begin_src js
  /**
   ,* Returns a list of layers of task sorted as late as possible,
   ,* the tasks within each layer can be executed in parallel.
   ,*
   ,* @arg {Entries} entries
   ,* @return {Layers}
   ,*/
  function alap(entries) {
    const dependencies = buildGraph(entries);
    const layers = layeredTopologicalSort(dependencies[1], dependencies[0]);
    layers.reverse();
    return layers;
  }
#+end_src

** ASAP
#+name: asap
#+begin_src js
  /**
   ,* Returns a list of layers of task sorted as soon as possible,
   ,* the tasks within each layer can be executed in parallel.
   ,*
   ,* @arg {Entry[]} entries
   ,* @return {Layers}
   ,*/
  function asap(entries) {
    const dependencies = buildGraph(entries);
    return layeredTopologicalSort(dependencies[0], dependencies[1]);
  }
#+end_src

** Build graph
#+name: buildGraph
#+begin_src js
  /**
   ,* @arg {Entry[]} entries
   ,* @return {[Dependencies, Dependencies]}
   ,*/
  function buildGraph(entries) {
    /** @type {Dependencies} */
    const dependenciesToFrom = Object.create(null);
    /** @type {Dependencies} */
    const dependenciesFromTo = Object.create(null);

    // Build the dependencies graph
    for (const entry of entries) {
      const entryId = entry[0];
      dependenciesToFrom[entryId] = Object.create(null);
      if (!dependenciesFromTo[entryId]) dependenciesFromTo[entryId] = Object.create(null);
      const entryDeps = entry[1];
      for (const entryDep of entryDeps) {
        dependenciesToFrom[entryId][entryDep] = true;
        if (!dependenciesFromTo[entryDep]) dependenciesFromTo[entryDep] = Object.create(null);
        dependenciesFromTo[entryDep][entryId] = true;
      }
    }
    return [dependenciesToFrom, dependenciesFromTo];
  }
#+end_src

** Layered topological sort
#+name: layeredTopologicalSort
#+begin_src js
  /**
   ,* LayeredTopologicalSort returns a list of layers of entries,
   ,* the entries within each layer can be executed in parallel.
   ,*
   ,* @arg {Dependencies} dependenciesToFrom
   ,* @arg {Dependencies} dependenciesFromTo
   ,* @return {Layers}
   ,*/
  function layeredTopologicalSort(dependenciesToFrom, dependenciesFromTo) {
    /** @type {Layers} */
    const layers = [];

    while (0 < Object.keys(dependenciesToFrom).length) {
      /** @type {string[]} */
      const thisIterationIds = [];

      for (const k in dependenciesToFrom) {
        const v = dependenciesToFrom[k];

        // If an item has zero dependencies, remove it
        if (Object.keys(v).length === 0) thisIterationIds.push(k);
      }

      // if nothing was found to remove, there's no valid sort
      if (thisIterationIds.length === 0) return [];

      /** @type {string[]} */
      const layer = [];
      for (const id of thisIterationIds) {
        // Add them to the overall ordering
        layer.push(id);

        // Remove the found items from the dictionary
        delete dependenciesToFrom[id];

        // Remove all outbound edges
        if (dependenciesFromTo[id]) {
          for (const dep in dependenciesFromTo[id]) {
            delete dependenciesToFrom[dep][id];
          }
        }
      }
      layers.push(layer);
    }
    return layers;
  }
#+end_src

#+name: main
#+begin_src js :noweb yes :exports none
  <<layeredTopologicalSort>>

  <<buildGraph>>

  <<asap>>

  <<alap>>
#+end_src

#+begin_src js :noweb yes :tangle layeredTopologicalSort.js :exports none
  <<types>>

  <<main>>

  export { alap, asap };
#+end_src

#+name: test
#+begin_src js :noweb yes :exports none
  ; <<main>>
  function asaplog(expected) { log(asap(entries), expected); }
  function alaplog(expected) { log(alap(entries), expected); }
  function log(result, expected) {
    const res = JSON.stringify(result);
    const exp = JSON.stringify(expected);
    const out = res === exp ? result : `Result does not match expected: ${res} !== ${exp}`;
    console.log(out);
  }
#+end_src
